// Mostly generated by chatgpt
// https://chat.openai.com/share/64ad8da7-86e6-4742-a60e-aef3eafebb9c

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"os"
	"time"

	MQTT "github.com/eclipse/paho.mqtt.golang"
)

const (
	shellyDeviceID    = "shellycolorbulb-mock"
	commandTopic      = "shellies/" + shellyDeviceID + "/color/0/command"
	setTopic          = "shellies/" + shellyDeviceID + "/color/0/set"
	statusTopic       = "shellies/" + shellyDeviceID + "/color/0/status"
	powerTopic        = "shellies/" + shellyDeviceID + "/light/0/power"
	energyTopic       = "shellies/" + shellyDeviceID + "/light/0/energy"
	initialBrightness = 100
	initialRed        = 255
	initialGreen      = 255
	initialBlue       = 255
	initialWhite      = 255
)

type ShellyStatus struct {
	IsOn           bool   `json:"ison"`
	HasTimer       bool   `json:"has_timer"`
	TimerStarted   int64  `json:"timer_started"`
	TimerDuration  int    `json:"timer_duration"`
	TimerRemaining int    `json:"timer_remaining"`
	Mode           string `json:"mode"`
	Red            int    `json:"red"`
	Green          int    `json:"green"`
	Blue           int    `json:"blue"`
	White          int    `json:"white"`
	Gain           int    `json:"gain"`
	Temp           int    `json:"temp"`
	Brightness     int    `json:"brightness"`
	Effect         int    `json:"effect"`
}

var currentStatus ShellyStatus

func main() {
	opts := MQTT.NewClientOptions().AddBroker(os.Getenv("MQTT_SERVER"))

	client := MQTT.NewClient(opts)
	if token := client.Connect(); token.Wait() && token.Error() != nil {
		panic(token.Error())
	}

	// Subscribe to topics
	if token := client.Subscribe(commandTopic, 0, commandHandler); token.Wait() && token.Error() != nil {
		panic(token.Error())
	}
	if token := client.Subscribe(setTopic, 0, setHandler); token.Wait() && token.Error() != nil {
		panic(token.Error())
	}

	// Start publishing status updates periodically
	go func() {
		for {
			publishStatus(client)
			time.Sleep(15 * time.Second) // Publish status every 5 seconds
		}
	}()

	// Serve HTTP
	http.HandleFunc("/", colorHandler)
	http.HandleFunc("/echo", colorEchoHandler)
	log.Fatal(http.ListenAndServe(":3333", nil))
}

func commandHandler(client MQTT.Client, msg MQTT.Message) {
	command := string(msg.Payload())
	fmt.Printf("Received command: %s\n", command)

	switch command {
	case "on":
		currentStatus.IsOn = true
	case "off":
		currentStatus.IsOn = false
	case "toggle":
		currentStatus.IsOn = !currentStatus.IsOn
	}

	// Publish updated status
	publishStatus(client)
}

func setHandler(client MQTT.Client, msg MQTT.Message) {
	var newSettings ShellyStatus
	err := json.Unmarshal(msg.Payload(), &newSettings)
	if err != nil {
		log.Printf("Error unmarshaling JSON: %v", err)
		return
	}

	fmt.Printf("Received new settings: %+v\n", newSettings)

	// Apply new settings
	currentStatus.IsOn = true
	currentStatus.Mode = newSettings.Mode
	currentStatus.Red = newSettings.Red
	currentStatus.Green = newSettings.Green
	currentStatus.Blue = newSettings.Blue
	currentStatus.White = newSettings.White
	currentStatus.Gain = newSettings.Gain
	currentStatus.Temp = newSettings.Temp
	currentStatus.Brightness = newSettings.Brightness
	currentStatus.Effect = newSettings.Effect

	// Publish updated status
	publishStatus(client)
}

func publishStatus(client MQTT.Client) {
	payload, err := json.Marshal(currentStatus)
	if err != nil {
		log.Printf("Error marshaling JSON: %v", err)
		return
	}

	token := client.Publish(statusTopic, 0, false, payload)
	token.Wait()
	if token.Error() != nil {
		log.Printf("Error publishing status: %v", token.Error())
	}

	// Publish mock power and energy data
	publishPower(client)
	publishEnergy(client)
}

func publishPower(client MQTT.Client) {
	payload := []byte(fmt.Sprintf("%d", rand.Intn(10)))
	token := client.Publish(powerTopic, 0, false, payload)
	token.Wait()
	if token.Error() != nil {
		log.Printf("Error publishing power: %v", token.Error())
	}
}

func publishEnergy(client MQTT.Client) {
	payload := []byte(fmt.Sprintf("%d", rand.Intn(1000)))
	token := client.Publish(energyTopic, 0, false, payload)
	token.Wait()
	if token.Error() != nil {
		log.Printf("Error publishing energy: %v", token.Error())
	}
}

func colorHandler(w http.ResponseWriter, r *http.Request) {
	var color string
	if currentStatus.IsOn {
		if currentStatus.Mode == "color" {
			color = fmt.Sprintf("rgb(%d, %d, %d)", currentStatus.Red, currentStatus.Green, currentStatus.Blue)
		} else if currentStatus.Mode == "white" {
			// Convert color temperature to RGB
			red, green, blue := colorTempToRGB(currentStatus.Temp)
			color = fmt.Sprintf("rgb(%d, %d, %d)", red, green, blue)
		}
	} else {
		color = "black"
	}
	fmt.Fprintf(w, "<div style='width: 100%%; height: 100%%; background-color: %s'></div>", color)
}

func colorEchoHandler(w http.ResponseWriter, r *http.Request) {
	var red int
	var g int
	var b int

	if currentStatus.IsOn {
		if currentStatus.Mode == "color" {
			red = currentStatus.Red
			g = currentStatus.Green
			b = currentStatus.Blue
		} else if currentStatus.Mode == "white" {
			// Convert color temperature to RGB
			red, g, b = colorTempToRGB(currentStatus.Temp)
		}
	} else {
		red = 0
		g = 0
		b = 0
	}
	fmt.Fprintf(w, `\033[38;2;%d;%d;%dmâ¬¤\033[0m`, red, g, b)
}

func colorTempToRGB(temp int) (int, int, int) {
	// Convert color temperature to RGB
	var red, green, blue int

	if temp <= 6500 && temp >= 5000 {
		red = 255
		green = int((6500 - temp) / 1500.0 * 255)
		blue = 0
	} else if temp < 5000 && temp >= 3000 {
		red = 255
		green = 255
		blue = int((temp - 3000) / 2000.0 * 255)
	} else {
		red = 0
		green = 0
		blue = 255
	}

	return red, green, blue
}
